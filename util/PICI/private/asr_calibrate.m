function [covariance_matrix,mixing_matrix,state_ord0,state_ord1,state_ord2,state_buffer] = asr_calibrate(data,srate,window_len,processing_delay,flt_b,flt_a)
% Calibrate the ASR method.
% [CovarianceMatrix,MixingMatrix,ShapingB,ShapingA,StateOrd1,StateOrd2,StateBuffer] = asr_calibrate(Data,SamplingRate,WindowLength,LookAhead,FilterB,FilterA)
%
% The input to this data is a multi-channel time series of calibration data. The calibration data
% should be reasonably clean resting EEG of ca. 1 minute duration (can also be longer).
%
% The calibration data must have been recorded for the same cap design that shall be used online,
% and ideally should be from the same session and same subject, but it is possible to reuse the
% calibration data from a previous session and montage as long as the cap is placed approx. in the
% same location.
%
% The calibration data should have been high-pass filtered (for example at 0.5Hz or 1Hz using a
% Butterworth IIR filter) and channels that deliver only noise should have been removed beforehand.
%
% In:
%   Data : Calibration data [#channels x #samples]. This data should come from resting EEG and
%          should be ca. 1 minute in length. The data should be high-pass filtered and of type double.
%
%   SamplingRate : Sampling rate of the data in Hz (e.g., 250.0)
%
%   WindowLength : Length of the statistcs window, in seconds (e.g., 0.5). This should not be much
%                  longer than the time scale over which artifacts persist, but the number of samples
%                  in the window should not be smaller than 1.5x the number of channels.
%
%   LookAhead : Amount of look-ahead that the algorithm should use. Since the processing is causal,
%               the output signal will be delayed by this amount. This value is in seconds and should
%               be between 0 (no lookahead) and WindowLength/2 (optimal lookahead). The recommended
%               value is WindowLength/2.
%
%   FilterB, FilterA : Coefficients of an IIR filter that is used to shape the spectrum of the signal
%                      when calculating artifact statistics. The output signal does not go through this
%                      filter. A good filter is generated by the following expression:
%                      [b,a] = yulewalk(6, [2*[0 2 3 13 14]/srate 1], [1 0.75 0.3 0.3 1 1]);
%
% Out:
%   CovarianceMatrix : the covariance matrix C of the data
%
%   MixingMatrix : the mixing matrix M of the data
%
%   StateOrd0 : zeroth-order initial filter state
%
%   StateOrd1 : first-order initial filter state
%
%   StateOrd2 : second-order initial filter state
%
%   StateBuffer : initial buffer state
%
%                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD
%                                2012-08-31

max_iters=500;

[C,S] = size(data);                  % size of the data
P = round(processing_delay*srate);   % number of time points of look-ahead
N = round(max(C*1.5,window_len*srate)); % number of time points in the statistics window (making sure that it's long enough)
wnd = 0:N-1;                         % index vector for the sliding window
offsets = 1 + floor(0:N:S-N);        % vector of offsets in the Data from which we compute statistics
W = length(offsets);                 % number of offsets

if S < N*10
    error('The calibration data needs to be at least 10x the length of the statistics window length. Ideally you should have circa 1 minute of data.'); end
if P > N/2+1
    error('The look-ahead should not be larger than WindowLength/2.'); end
if isempty(data)
    error('Your data matrix is empty.'); end

% get rid of NaN's and Inf's
data(~isfinite(double(data(:)))) = 0;
if isempty(data)
    error('Your data matrix contained only NaNs or Infs.'); end

% apply the shaping filter, get the initial filter state and the covariance matrix of the calibration data
[data,state_ord0] = filter(flt_b,flt_a,data,[],2);
if any(~isfinite(data))
    error('The IIR filter diverged on your data. Please try using either a more conservative filter or removing some bad sections/channels from the calibration data.'); end

% calculate the covariance matrix and Cholesky
% factorization for each data segment
wndcovs = complex(zeros(C,C,W));
wndchols = complex(zeros(C*C,W));
invalid = zeros(1,W);
for o=1:W
    wndcov = cov(data(:,offsets(o) + wnd)');
    wndcovs(:,:,o) = wndcov;
    [tmp,invalid(o)] = chol(wndcov);
    if ~invalid(o)
        wndchols(:,o) = reshape(tmp,C*C,1); end
end
% if the data appears to be rank-deficit, we use eigenvectors instead
if nnz(invalid)/length(invalid) > 0.5
    disp('Note: your data is probably rank-deficit (e.g., due to shorted channels) or otherwise numerically problematic; the calibration measure will likely be of lower quality.');
    invalid = zeros(1,W);
    for o=1:W
        [U,D] = eig((wndcovs(:,:,o)+wndcovs(:,:,o)')/2);
        [D,order] = sort(diag(D),'descend'); U = U(:,order);
        % reorient eigenvectors
        [dummy,maxind] = max(abs(U),[],1); %#ok<ASGLU>
        negloc = (U(maxind + (0:C:(C-1)*C)) < 0);
        U(:,negloc) = -U(:,negloc);
        retain = D>eps(max(D)) * length(D);
        tmp = eye(C); part = diag(sqrt(D(retain))) * U(:,retain)'; tmp(1:size(part,1),1:size(part,2)) = part;
        wndchols(:,o) = reshape(tmp,C*C,1);
    end
end
wndchols = wndchols(:,~invalid);
if all(invalid) || ~all(isfinite(wndchols(:)))
    error('Cannot compute statistics on the calibration data. Some of your channels are probably causing numeric instability.'); end

% take the geometric median (using Weiszfeld's algorithm)
% ... and then map it back into covariance space
wndchols = reshape(wndchols,C*C,[])';
medchol = median(wndchols);
for i=1:max_iters
    diffs = bsxfun(@minus,wndchols,medchol);
    invnorms = 1./sqrt(sum(diffs.*diffs,2));
    [medchol,oldmedchol] = deal(sum(bsxfun(@times,wndchols,invnorms)) / sum(invnorms),medchol);
    if norm(medchol-oldmedchol)/norm(medchol) < 1.e-5
        break; end
end
if i==max_iters
    disp('Could not calibrate the reference measure to the desired tolerance; most likely your calibration data causes numeric instability.'); end
medchol = reshape(medchol,C,C);
covariance_matrix = medchol'*medchol;

% get the mixing matrix from it, too
mixing_matrix = real(sqrtm(covariance_matrix));

% condition the covariance matrix to closely match the median variance
vars = zeros(C,length(offsets));
for o=1:W
    vars(:,o) = real(reshape(diag(wndcovs(:,:,o)),C,1)); end
covariance_matrix = covariance_matrix * diag(median(vars,2) ./ reshape(diag(covariance_matrix),C,1));
% and do another pass using random projections...
rot = orth(randn(C));
rotdata = rot' * data;
for o=1:W
    vars(:,o) = real(var(rotdata(:,offsets(o) + wnd),0,2)); end
rescaling = diag(median(vars,2) ./ reshape(diag(rot'*covariance_matrix*rot),C,1));
% ... to get the off-diagonal elements right (applying it as rotate - scale - rotate back)
covariance_matrix = rot' * covariance_matrix * rot;
covariance_matrix = covariance_matrix * rescaling;
covariance_matrix = rot * covariance_matrix * rot';
covariance_matrix = real(covariance_matrix);

% initialize the remaining filter state
state_ord1 = [];
state_ord2 = [];
state_buffer = data(:,(end-P+1):end);
